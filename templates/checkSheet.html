<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>체크시트 페이지</title>
    <!-- Font Awesome 아이콘 라이브러리 추가 -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/font-awesome.min.css') }}">
    <style>
        /* 커스텀 확인 모달 스타일 */
        .custom-confirm-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.2s ease-out;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        @keyframes slideUp {
            from {
                transform: translate(-50%, -45%) scale(0.95);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        
        .custom-confirm-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 0;
            width: 420px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
            overflow: hidden;
            animation: slideUp 0.3s ease-out;
        }
        
        .custom-confirm-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 25px;
            position: relative;
            overflow: hidden;
        }
        
        .custom-confirm-header::before {
            content: "⚠️";
            font-size: 40px;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.3;
        }
        
        .custom-confirm-title {
            color: white;
            font-size: 20px;
            font-weight: 600;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .custom-confirm-message {
            padding: 25px;
            font-size: 16px;
            color: #495057;
            line-height: 1.6;
            background: white;
        }
        
        .custom-confirm-buttons {
            display: flex;
            padding: 0 25px 25px 25px;
            gap: 12px;
            background: white;
        }
        
        .custom-confirm-buttons button {
            flex: 1;
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .custom-confirm-save {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .custom-confirm-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }
        
        .custom-confirm-cancel {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #495057;
        }
        
        .custom-confirm-cancel:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: white;
        }
        
        .custom-confirm-cancel:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(252, 182, 159, 0.3), 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .custom-confirm-save:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3), 0 6px 12px rgba(102, 126, 234, 0.4);
        }
        
        .custom-confirm-exit {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8a80 100%);
            color: white;
        }
        
        .custom-confirm-exit:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4);
        }
        
        .custom-confirm-exit:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.3), 0 6px 12px rgba(255, 107, 107, 0.4);
        }
        
        /* 전체 페이지 스타일 설정 */
        body, input, button, select {
            font-size: 20px;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            color: #333;
            display: flex;
            transition: margin-right 0.5s;
        }
        h1 {
            color: #0056b3;
        }
        form {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        select, input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            margin-bottom: 20px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            background-color: #45a049;
        }
        button:active {
            background-color: #3e8c43;
            transform: scale(0.98);
        }
        /* 캔버스 스타일 설정 */
        canvas {
            border: 1px solid #000000;
            touch-action: none;
        }
        /* 에러 메시지 스타일 */
        #error {
            color: red;
        }
        #drawingCanvas {
            cursor: url("{{ pen_cursor_url }}"), auto; /* 캔버스 위에서 마우스 커서를 펜 모양으로 변경 */
        }
        #drawingCanvas.eraser-mode {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"><rect x="2" y="7" width="20" height="10" rx="2" fill="pink" stroke="black"/><line x1="2" y1="12" x2="22" y2="12" stroke="black"/></svg>') 12 12, crosshair;
        }
        /* 지우개 버튼 스타일 */
        #eraserButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: white;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            display: none; /* 초기에는 숨김 */
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #eraserButton:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #eraserButton.active {
            background-color: #ddd;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }
        #eraserButton i {
            font-size: 24px;
            color: #333;
        }
        #eraserButton.active i {
            color: #0056b3;
        }
        /* 사이드바 스타일 설정 */
        .sidebar {
            height: 100vh;
            width: 50px; /* 초기 너비 설정 */
            position: fixed;
            z-index: 1;
            top: 0;
            left: 0;
            background-color: #111;
            overflow-x: hidden;
            transition: width 0.5s;
            padding-top: 20px;
        }
        /* 사이드바 링크 스타일 */
        .sidebar a {
            padding: 10px 15px;
            text-decoration: none;
            font-size: 25px;
            color: white;
            display: block;
            transition: 0.3s;
        }
        .sidebar a:hover {
            color: #f1f1f1;
        }
        .sidebar .closebtn {
            position: absolute;
            top: 0;
            right: 25px;
            font-size: 36px;
            margin-left: 50px;
        }
        .link-text {
            display: inline; /* 기본적으로 텍스트 표시 */
        }
        /* 사이드바 확장/축소 시 스타일 변경 */
        .sidebar.collapsed .link-text {
            display: none; /* 축소된 상태에서는 텍스트 숨김 */
        }

        .sidebar:not(.collapsed) .link-text {
            display: inline; /* 확장된 상태에서 텍스트 표시 */
        }

        .sidebar.collapsed {
            width: 50px; /* 축소된 상태의 사이드바 너비 */
        }

        .sidebar:not(.collapsed) {
            width: 250px; /* 확장된 상태의 사이드 너비 */
        }
        .sidebar.collapsed + #main {
            margin-left: 50px; /* 사바가 축소되었을 때의 marginLeft */
        }

        .sidebar:not(.collapsed) + #main {
            margin-left: 250px; /* 사이드바가 확장되었을 때의 marginLeft */
        }
        /* 메인 컨텐츠 영역 스타일 */
        #main {
            transition: margin-right 0.5s, margin-left 0.5s ease;
            padding: 16px;
            flex-grow: 1;
            margin-right: 50px; /* 초기 marginRight 설정 */
        }
        .openbtn {
            font-size: 20px;
            cursor: pointer;
            background-color: #111;
            color: white;
            border: none;
            padding: 10px 20px;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 50px; /* 너비 조정 */
            height: 50px; /* 높이 조정 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sidebar.collapsed .openbtn {
            left: calc(50px - 50px / 2); /* 축소된 사이드바 중앙에 위치 */
        }
        .openbtn:hover {
            background-color: #444;
        }

        /* 메시지 컨테이너 스타일 */
        #messages-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 개별 메시지 스타일 */
        .message {
            background-color: #f44336; /* 기본 빨간색 */
            color: white; /* 흰색 텍스트 */
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            opacity: 0.9;
            transition: opacity 0.5s ease;
            min-width: 200px;
            text-align: center;
        }

        /* 메시지가 사라질 때의 효과 */
        .message.hide {
            opacity: 0;
        }

        /* 제품 정보 컨테이너 스타일 */
        #productInfoContainer {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 10px 0;
        }

        .product-info {
            display: inline-block;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        /* Sticky header 스타일 */
        #productInfoContainer {
            background-color: white;
            padding: 15px;
            border-bottom: 2px solid #ccc;
            transition: all 0.3s ease;
            z-index: 999;
            box-shadow: none;
            margin-bottom: 10px;
        }
        
        #productInfoContainer.sticky {
            position: fixed;
            top: 0;
            left: 50px; /* 사이드바 토글 버튼 고려 */
            right: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
            }
            to {
                transform: translateY(0);
            }
        }
        
        /* Sticky 상태일 때 placeholder 역할 */
        .sticky-placeholder {
            display: none;
            height: 100px; /* productInfoContainer 높이에 맞춤 */
        }
        
        #productInfoContainer.sticky ~ .sticky-placeholder {
            display: block;
        }
        
        /* 사이드바가 열려있을 때 sticky header 위치 조정 */
        .sidebar-expanded #productInfoContainer.sticky {
            left: 250px;
            width: calc(100% - 250px);
        }
        
        /* 작은 이미지일 때는 sticky 비활성화 */
        #productInfoContainer.no-sticky {
            position: static !important;
        }
        
        /* 로딩 스피너(모래시계) 컨테이너 */
        #loadingSpinner {
            display: none;         /* 기본적으로 숨김 */
            position: fixed;       /* 화면 중앙 고정 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;         /* 다른 요소보다 위에 표시 */
        }
        /* 스피너 모양을 만드는 예시(원형 회전) */
        .spinner {
            border: 16px solid #f3f3f3; /* 라이트 그레이 */
            border-top: 16px solid #3498db; /* 파란색 */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
<body onload="focusOnBarcodeInput()">
    <!-- 커스텀 확인 모달 -->
    <div id="customConfirmModal" class="custom-confirm-modal">
        <div class="custom-confirm-content">
            <div class="custom-confirm-header">
                <h3 class="custom-confirm-title">저장 확인</h3>
            </div>
            <div class="custom-confirm-message">
                현재 체크시트가 완료되지 않았습니다.<br>
                저장하시겠습니까?
            </div>
            <div class="custom-confirm-buttons">
                <button class="custom-confirm-save" id="confirmSaveBtn">저장</button>
                <button class="custom-confirm-cancel" id="confirmCancelBtn">취소</button>
                <button class="custom-confirm-exit" id="confirmExitBtn">나가기</button>
            </div>
        </div>
    </div>
    
    <!-- 3186 공정 체크박스 미체크 확인 모달 -->
    <div id="uncheckedConfirmModal" class="custom-confirm-modal">
        <div class="custom-confirm-content">
            <div class="custom-confirm-header">
                <h3 class="custom-confirm-title">미체크 항목 확인</h3>
            </div>
            <div class="custom-confirm-message">
                미체크 항목이 있습니다.<br>
                저장하시겠습니까?
            </div>
            <div class="custom-confirm-buttons">
                <button class="custom-confirm-save" id="uncheckedSaveBtn">저장</button>
                <button class="custom-confirm-cancel" id="uncheckedCancelBtn">취소</button>
            </div>
        </div>
    </div>
    
    <!-- 사이드바 구조 -->
    <div id="mySidebar" class="sidebar collapsed">
        <!-- 사이드바 메뉴 항목들 -->
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">×</a>
        <a href="/login"><i class="fa fa-home"></i><span class="link-text"> 로그인</span></a>
        <a href="#"><i class="fa fa-check-square-o"></i><span class="link-text"> 체크시트</span></a>
        <a href="/checksheet-history"><i class="fa fa-history"></i><span class="link-text"> 이력관리</span></a>
        <a href="/logout"><i class="fa fa-sign-out"></i><span class="link-text"> 로그아웃</span></a>
    </div>
    <!-- 사이드바 토글 버튼 -->
    <button class="openbtn" onclick="toggleNav()">☰</button> <!-- 기존의 햄버거 메뉴 아이콘을 사용 -->
    <!-- 메인 컨텐츠 영역 -->
    <div id="main">
        <h1>체크시트 페이지</h1>
        <!-- 사용자 정보 표시 -->
        <p><strong>담당 작업자:</strong> <span id="employeeName"></span></p>
        <p><strong>담당 라인:</strong> <span id="deptInfo"></span></p>
        <!-- 바코드 입력 폼 -->
        <form id="barcode-form">
            <!-- 공정 선택 드롭다운 -->
            <label for="processSelect">공정 선택:</label> 
            <select id="processSelect" name="processSelect">P
            {% if "JUXTA" in dept_info %}
                <!-- 공정 옵션들JUXTA 전용 공정 -->
                <option value="04">JUXTA 부품SET</option>
                <option value="07">JUXTA 조립</option>
                <option value="10">JUXTA 2자검사</option>
                <option value="11">JUXTA 포장</option>
            {% else %}
                <!-- 기존 UTA 공정 -->
                <option value="08">부품SET</option>
                <option value="06">단자체결기</option>
                <option value="11">조립</option>
                <option value="15">출하검사</option>
            {% endif %}
            </select>
            <br><br>
            <!-- 바코드 입력 필드 -->
            <label for="barcodeInput">바코드 입력:</label>
            <input type="text" id="barcodeInput" name="barcodeInput" autofocus inputmode="ascii" oninput="validateInput(this);" />
            <input type="submit" value="Submit" style="display: none;">
            <!-- 제품 정보와 체크 완료 버튼을 감싸는 컨테이너 추가 -->
            <div id="productInfoContainer" style="display: none;">
                <button type="button" id="checkCompleteButton">체크 완료</button>
                <div class="product-info">
                    <strong>Index No:</strong> <span id="indexNo"></span> &nbsp;|&nbsp;
                    <strong>MS-CODE:</strong> <span id="msCode"></span> &nbsp;|&nbsp;
                    <strong>Serial No:</strong> <span id="serialNo"></span> &nbsp;|&nbsp;
                    <strong>착공 No:</strong> <span id="construction_No"></span>
                </div>
                <!-- 페이지 네비게이션 버튼 (JUXTA 10, 11번 공정용) -->
                <div id="pageNavigation" style="display: none; margin-left: 20px;">
                    <button type="button" id="prevPageButton" onclick="switchToPage('prev')">이전 페이지</button>
                    <button type="button" id="nextPageButton" onclick="switchToPage('next')">다음 페이지</button>
                </div>
            </div>
            <!-- Sticky placeholder -->
            <div class="sticky-placeholder"></div>
            <!-- 에러 메시지 표시 영역 -->
            <p id="error" style="color: red;"></p>
            <!-- 이미지 표시 영역 -->
            <div id="canvasContainer" style="display: none; position: relative; width: auto; height: auto; overflow: hidden;">
                <canvas id="baseImageCanvas" width="800" height="600" style="position: absolute; border:1px solid #000000;"></canvas>
                <canvas id="drawingCanvas" width="800" height="600" style="position: absolute; border:1px solid #000000;"></canvas>
            </div>
        </form>
    </div>
    
    <!-- 지우개 버튼 추가 -->
    <button id="eraserButton" type="button" title="지우개 모드" onclick="toggleEraserMode()">
        <i class="fa fa-eraser"></i>
    </button>

    <!-- 메시지 컨테이너 추가 -->
    <div id="messages-container"></div>
    <!-- 로딩 스피너 추가 -->
    <div id="loadingSpinner">
        <div class="spinner"></div>
    </div>
    <script>
        // 전역 변수로 지우개 모드 상태 선언
        let eraserMode = false;
        
        // 페이지 관리를 위한 전역 변수
        let currentPage = 1; // 1: 첫 페이지(04번), 2: 두 번째 페이지(10번 or 11번)
        let page1Canvas = null; // 04번 이미지 캔버스 저장
        let page2Canvas = null; // 10번/11번 이미지 캔버스 저장
        let page1CheckBoxStates = {}; // 04번 체크박스 상태
        let page2CheckBoxStates = {}; // 10번/11번 체크박스 상태
        let page1CheckBoxes = []; // 04번 체크박스 위치 정보
        let page2CheckBoxes = []; // 11번 체크박스 위치 정보
        let currentProductInfo = null; // 현재 제품 정보 저장
        let originalProcessCode = null; // 원래 선택된 공정 코드 (10 or 11)
        
        // 지우개 모드 토글 함수 - 전역 함수로 선언
        function toggleEraserMode() {
            console.log('=== toggleEraserMode 함수 호출됨 ===');
            console.log('현재 eraserMode:', eraserMode);
            
            eraserMode = !eraserMode;
            console.log('변경된 eraserMode:', eraserMode);
            
            const eraserBtn = document.getElementById('eraserButton');
            const drawingCanvas = document.getElementById('drawingCanvas');
            
            if (eraserBtn) {
                if (eraserMode) {
                    eraserBtn.classList.add('active');
                    console.log('버튼에 active 클래스 추가');
                } else {
                    eraserBtn.classList.remove('active');
                    console.log('버튼에서 active 클래스 제거');
                }
                console.log('버튼 클래스 목록:', eraserBtn.className);
            }
            
            if (drawingCanvas) {
                if (eraserMode) {
                    drawingCanvas.classList.add('eraser-mode');
                    // 지우개 커서 - SVG 파일 사용
                    drawingCanvas.style.cursor = 'url("/static/icon/eraser-cursor.svg") 12 12, crosshair';
                    console.log('커서를 지우개로 변경');
                } else {
                    drawingCanvas.classList.remove('eraser-mode');
                    drawingCanvas.style.cursor = 'url("{{ pen_cursor_url }}"), auto';
                    console.log('커서를 펜으로 변경');
                }
            }
            
            console.log('=== toggleEraserMode 함수 종료 ===');
        }
        
        // 페이지 전환 함수
        // 페이지 전환 함수 - window에 할당하여 onclick에서 접근 가능하게 함
        window.switchToPage = function(direction) {
            console.log('페이지 전환:', direction, '현재 페이지:', currentPage);
            console.log('originalProcessCode:', originalProcessCode);
            
            // 현재 캔버스 상태 저장
            saveCurrentPageState();
            
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            const checkCompleteBtn = document.getElementById('checkCompleteButton');
            
            if (direction === 'next' && currentPage === 1) {
                // 04번 → 10번/11번으로 전환
                currentPage = 2;
                // originalProcessCode를 사용 (10 또는 11)
                if (originalProcessCode) {
                    console.log('다음 페이지로 전환 - 프로세스:', originalProcessCode);
                    loadPageImage(originalProcessCode);
                    
                    // 11번 공정일 때만 체크완료 버튼 활성화
                    if (originalProcessCode === '11' && checkCompleteBtn) {
                        checkCompleteBtn.disabled = false;
                        checkCompleteBtn.style.backgroundColor = '';
                        checkCompleteBtn.style.cursor = 'pointer';
                    }
                } else {
                    console.error('originalProcessCode가 설정되지 않았습니다');
                }
                document.getElementById('prevPageButton').disabled = false;
                document.getElementById('nextPageButton').disabled = true;
            } else if (direction === 'prev' && currentPage === 2) {
                // 10번/11번 → 04번으로 전환
                currentPage = 1;
                console.log('이전 페이지로 전환 - 프로세스: 04');
                loadPageImage('04');
                document.getElementById('prevPageButton').disabled = true;
                document.getElementById('nextPageButton').disabled = false;
                
                // 11번 공정일 때 04페이지에서 체크완료 버튼 비활성화
                if (originalProcessCode === '11' && checkCompleteBtn) {
                    checkCompleteBtn.disabled = true;
                    checkCompleteBtn.style.backgroundColor = '#ccc';
                    checkCompleteBtn.style.cursor = 'not-allowed';
                }
            }
        }
        
        // 현재 페이지 상태 저장
        function saveCurrentPageState() {
            const baseCanvas = document.getElementById('baseImageCanvas');
            const drawingCanvas = document.getElementById('drawingCanvas');
            
            if (!baseCanvas || !drawingCanvas) return;
            
            // 캔버스 복사본 생성 (원본 크기 유지)
            const savedCanvas = document.createElement('canvas');
            savedCanvas.width = baseCanvas.width;
            savedCanvas.height = baseCanvas.height;
            const savedCtx = savedCanvas.getContext('2d', { willReadFrequently: true });
            
            // base 이미지와 drawing 합치기 (원본 크기로)
            savedCtx.drawImage(baseCanvas, 0, 0, baseCanvas.width, baseCanvas.height);
            savedCtx.drawImage(drawingCanvas, 0, 0, drawingCanvas.width, drawingCanvas.height);
            
            if (currentPage === 1) {
                page1Canvas = savedCanvas;
                page1CheckBoxStates = {...checkBoxStates};
                page1CheckBoxes = checkBoxes ? [...checkBoxes] : [];  // 체크박스 위치 정보도 저장
                console.log('04번 페이지 상태 저장됨 - 크기:', savedCanvas.width, 'x', savedCanvas.height);
                console.log('04번 페이지 체크박스 개수:', page1CheckBoxes.length);
            } else {
                page2Canvas = savedCanvas;
                page2CheckBoxStates = {...checkBoxStates};
                page2CheckBoxes = checkBoxes ? [...checkBoxes] : [];  // 체크박스 위치 정보도 저장
                console.log('10/11번 페이지 상태 저장됨 - 크기:', savedCanvas.width, 'x', savedCanvas.height);
                console.log('11번 페이지 체크박스 개수:', page2CheckBoxes.length);
            }
        }
        
        // 특정 공정의 이미지 로드
        function loadPageImage(processCode) {
            if (!currentProductInfo) {
                console.error('currentProductInfo가 없습니다');
                return;
            }
            
            console.log('loadPageImage 호출 - processCode:', processCode);
            
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            const processSelect = document.getElementById('processSelect');
            let selectedIndex = 0;
            
            // processCode가 10 또는 11일 때는 원래 선택된 인덱스 사용
            if (processCode === '10' || processCode === '11') {
                selectedIndex = processSelect.selectedIndex;
                console.log('10/11번 프로세스 - 현재 선택된 인덱스 사용:', selectedIndex);
            } else {
                // 04번 등 다른 프로세스는 해당 인덱스 찾기
                for (let i = 0; i < processSelect.options.length; i++) {
                    if (processSelect.options[i].value === processCode) {
                        selectedIndex = i;
                        break;
                    }
                }
                console.log('프로세스', processCode, '의 인덱스:', selectedIndex);
            }
            
            // 저장된 상태가 있으면 복원
            if (currentPage === 1 && page1Canvas) {
                console.log('저장된 04번 페이지 복원');
                restorePageState(page1Canvas, page1CheckBoxStates);
            } else if (currentPage === 2 && page2Canvas) {
                console.log('저장된 10/11번 페이지 복원');
                restorePageState(page2Canvas, page2CheckBoxStates);
            } else {
                // 새로 로드
                const uploadImageUrl = `/upload_image/${currentProductInfo.Index_No}_${deptCode}_${currentProductInfo.Serial_No}_${processCode}_${selectedIndex}`;
                console.log('새 이미지 로드:', processCode, uploadImageUrl);
                
                loadingSpinner.style.display = 'block';
                
                fetch(uploadImageUrl, {
                    method: 'GET',
                    headers: {'Accept': 'application/json'}
                })
                .then(response => {
                    if (!response.ok) throw new Error('이미지 로드 실패');
                    return response.json();
                })
                .then(imageData => {
                    if (imageData.image_url) {
                        loadImage(imageData.image_url);
                        checkBoxes = imageData.checkboxes || [];
                        
                        // 체크박스 상태 로드
                        return fetch(`/get_checkbox_states?indexNo=${encodeURIComponent(currentProductInfo.Index_No)}&serialNo=${encodeURIComponent(currentProductInfo.Serial_No)}&processCode=${encodeURIComponent(processCode)}&deptCode=${encodeURIComponent(deptCode)}`);
                    } else {
                        throw new Error('이미지 URL이 없습니다');
                    }
                })
                .then(response => response.json())
                .then(states => {
                    checkBoxStates = {};
                    if (states && Object.keys(states).length > 0) {
                        checkBoxStates = states;
                    } else {
                        checkBoxes.forEach((_, index) => {
                            checkBoxStates[index] = 'default';
                            if (isInteriorAllYellow(checkBoxes[index])) {
                                checkBoxStates[index] = 'default_n';
                            }
                        });
                    }
                    
                    // 현재 페이지의 체크박스 상태 저장
                    if (currentPage === 2) {
                        page2CheckBoxStates = {...checkBoxStates};
                    }
                    
                    redrawCheckboxes();
                    loadingSpinner.style.display = 'none';
                })
                .catch(error => {
                    console.error('이미지 로드 오류:', error);
                    loadingSpinner.style.display = 'none';
                });
            }
        }
        
        // 페이지 상태 복원
        function restorePageState(savedCanvas, savedCheckBoxStates) {
            const baseCanvas = document.getElementById('baseImageCanvas');
            const drawingCanvas = document.getElementById('drawingCanvas');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (!baseCanvas || !drawingCanvas || !savedCanvas) return;
            
            const baseCtx = baseCanvas.getContext('2d', { willReadFrequently: true });
            const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });
            
            // 캔버스 크기를 저장된 이미지의 원본 크기로 설정
            baseCanvas.width = savedCanvas.width;
            baseCanvas.height = savedCanvas.height;
            drawingCanvas.width = savedCanvas.width;
            drawingCanvas.height = savedCanvas.height;
            
            // 컨테이너 크기도 조정
            if (canvasContainer) {
                canvasContainer.style.width = savedCanvas.width + 'px';
                canvasContainer.style.height = savedCanvas.height + 'px';
            }
            
            // 캔버스 초기화
            baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // 저장된 이미지를 원본 크기로 복원
            baseCtx.drawImage(savedCanvas, 0, 0, savedCanvas.width, savedCanvas.height);
            
            // 체크박스 상태 복원
            checkBoxStates = {...savedCheckBoxStates};
            
            // 체크박스 다시 그리기
            redrawCheckboxes();
            
            console.log('페이지 상태 복원 완료 - 크기:', savedCanvas.width, 'x', savedCanvas.height);
        }
        
        // 두 페이지 모두 저장하는 함수 (JUXTA 공정 10/11용)
        function saveBothPages(currentSerialNo, deptCode) {
            const indexNo = indexNoDisplay.textContent;
            const empNo = document.getElementById('employeeName').textContent.split(' ')[0];
            
            // 페이지 1 (04번 공정) 저장
            const savePage1 = () => {
                return new Promise((resolve, reject) => {
                    // 04번 공정에 체크박스가 없는 경우 이미지만 저장
                    if (!page1CheckBoxStates || Object.keys(page1CheckBoxStates).length === 0) {
                        console.log('04번 공정: 체크박스 없음, 이미지만 저장');
                        
                        // 04번 공정 이미지만 저장
                        if (page1Canvas) {
                            page1Canvas.toBlob(function(blob) {
                                const formData = new FormData();
                                formData.append('image', blob, 'checked_image.png');
                                formData.append('serialNo', currentSerialNo);
                                formData.append('processCode', '04');
                                formData.append('deptCode', deptCode);
                                formData.append('empNo', empNo);
                                formData.append('indexNo', indexNo);
                                formData.append('result', 'OK'); // 체크박스가 없으면 기본 OK
                                
                                fetch('/save_checked_image', {
                                    method: 'POST',
                                    body: formData
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        console.log('04번 공정 이미지 저장 성공');
                                        resolve();
                                    } else {
                                        reject(new Error('04번 공정 이미지 저장 실패'));
                                    }
                                })
                                .catch(reject);
                            });
                        } else {
                            resolve(); // 캔버스도 없으면 그냥 넘어감
                        }
                        return;
                    }
                    
                    // 04번 공정 체크박스 상태 확인
                    let anyCrossed = false;
                    Object.values(page1CheckBoxStates).forEach(state => {
                        if (state === 'crossed' || state === 'default_n') {
                            anyCrossed = true;
                        }
                    });
                    const result = anyCrossed ? 'NG' : 'OK';
                    
                    // 04번 공정 체크박스 데이터 저장
                    const checkboxData = {
                        indexNo: indexNo,
                        serialNo: currentSerialNo,
                        deptCode: deptCode,
                        processCode: '04',
                        checkboxStates: page1CheckBoxStates,
                        originalStates: {},
                        checkboxPositions: page1CheckBoxes.reduce((acc, box, index) => {
                            acc[index] = {
                                x: box.x,
                                y: box.y,
                                width: box.width,
                                height: box.height
                            };
                            return acc;
                        }, {}),
                        empNo: empNo
                    };
                    
                    fetch('/save_checkbox_states', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(checkboxData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) throw new Error(data.error);
                        
                        // 04번 공정 이미지 저장
                        if (page1Canvas) {
                            page1Canvas.toBlob(function(blob) {
                                const formData = new FormData();
                                formData.append('image', blob, 'checked_image.png');
                                formData.append('serialNo', currentSerialNo);
                                formData.append('processCode', '04');
                                formData.append('deptCode', deptCode);
                                formData.append('empNo', empNo);
                                formData.append('indexNo', indexNo);
                                formData.append('result', result);
                                
                                fetch('/save_checked_image', {
                                    method: 'POST',
                                    body: formData
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        console.log('04번 공정 저장 완료');
                                        resolve();
                                    } else {
                                        reject(new Error('04번 공정 이미지 저장 실패'));
                                    }
                                })
                                .catch(reject);
                            });
                        } else {
                            resolve();
                        }
                    })
                    .catch(reject);
                });
            };
            
            // 페이지 2 (10번 또는 11번 공정) 저장
            const savePage2 = () => {
                return new Promise((resolve, reject) => {
                    // 10/11번 공정 체크박스 상태 확인
                    let anyCrossed = false;
                    Object.values(page2CheckBoxStates).forEach(state => {
                        if (state === 'crossed' || state === 'default_n') {
                            anyCrossed = true;
                        }
                    });
                    const result = anyCrossed ? 'NG' : 'OK';
                    
                    // 10/11번 공정 체크박스 데이터 저장
                    const checkboxData = {
                        indexNo: indexNo,
                        serialNo: currentSerialNo,
                        deptCode: deptCode,
                        processCode: originalProcessCode,
                        checkboxStates: page2CheckBoxStates,
                        originalStates: {},
                        checkboxPositions: page2CheckBoxes.reduce((acc, box, index) => {
                            acc[index] = {
                                x: box.x,
                                y: box.y,
                                width: box.width,
                                height: box.height
                            };
                            return acc;
                        }, {}),
                        empNo: empNo
                    };
                    
                    fetch('/save_checkbox_states', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(checkboxData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) throw new Error(data.error);
                        
                        // 10/11번 공정 이미지 저장
                        if (page2Canvas) {
                            page2Canvas.toBlob(function(blob) {
                                const formData = new FormData();
                                formData.append('image', blob, 'checked_image.png');
                                formData.append('serialNo', currentSerialNo);
                                formData.append('processCode', originalProcessCode);
                                formData.append('deptCode', deptCode);
                                formData.append('empNo', empNo);
                                formData.append('indexNo', indexNo);
                                formData.append('result', result);
                                
                                fetch('/save_checked_image', {
                                    method: 'POST',
                                    body: formData
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        console.log(`${originalProcessCode}번 공정 저장 완료`);
                                        resolve();
                                    } else {
                                        reject(new Error(`${originalProcessCode}번 공정 이미지 저장 실패`));
                                    }
                                })
                                .catch(reject);
                            });
                        } else {
                            resolve();
                        }
                    })
                    .catch(reject);
                });
            };
            
            // 두 페이지 모두 저장
            loadingSpinner.style.display = 'block';
            Promise.all([savePage1(), savePage2()])
                .then(() => {
                    loadingSpinner.style.display = 'none';
                    showMessage('두 페이지 모두 저장되었습니다.', 'success', currentSerialNo);
                    isCheckSheetModified = false;
                    
                    // 페이지 네비게이션 숨기고 초기화
                    document.getElementById('pageNavigation').style.display = 'none';
                    originalProcessCode = null;
                    currentPage = 1;
                    page1Canvas = null;
                    page2Canvas = null;
                    page1CheckBoxStates = {};
                    page2CheckBoxStates = {};
                    page1CheckBoxes = [];
                    page2CheckBoxes = [];
                })
                .catch(error => {
                    loadingSpinner.style.display = 'none';
                    console.error('saveBothPages 에러:', error);
                    showMessage(`체크시트 저장 중 오류가 발생했습니다: ${error.message}`, 'error');
                });
        }
        
        // 체크박스 상태 로드 함수
        function loadCheckboxStates(indexNo, serialNo, processCode, deptCode) {
            const url = `/get_checkbox_states?indexNo=${indexNo}&serialNo=${serialNo}&processCode=${processCode}&deptCode=${deptCode}`;
            
            fetch(url)
                .then(response => response.json())
                .then(states => {
                    checkBoxStates = states || {};
                    redrawCheckboxes();
                })
                .catch(error => {
                    console.error('체크박스 상태 로드 오류:', error);
                });
        }
        
        // focusOnBarcodeInput 함수 정의
        function focusOnBarcodeInput() {
            document.getElementById('barcodeInput').focus();
        }
        // 변수 선언
        const barcodeInput = document.getElementById('barcodeInput');
        const indexNoDisplay = document.getElementById('indexNo');    
        const msCodeDisplay = document.getElementById('msCode');
        const serialNoDisplay = document.getElementById('serialNo');
        const constructionNoDisplay = document.getElementById('construction_No');
        const errorDisplay = document.getElementById('error');
        const form = document.getElementById('upload-form');
        const baseImageCanvas = document.getElementById('baseImageCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const baseCtx = baseImageCanvas.getContext('2d', { willReadFrequently: true });
        const drawingCtx = drawingCanvas.getContext('2d', { willReadFrequently: true });
        const loadingSpinner = document.getElementById('loadingSpinner'); // 모래시계 아이콘

        let is_checked_image = false;
        let isCheckSheetModified = false;

        function rgbToHsv(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;

            let h = 0;
            let s = max === 0 ? 0 : diff / max;
            let v = max;

            if (diff !== 0) {
                if (max === r) {
                    h = ((g - b) / diff) % 6;
                } else if (max === g) {
                    h = (b - r) / diff + 2;
                } else {
                    h = (r - g) / diff + 4;
                }
            }

            h = Math.round(h * 60);
            if (h < 0) h += 360;

            return [h, Math.round(s * 100), Math.round(v * 100)];
        }

        function isPixelYellowOptimized(r, g, b) {
            // 1단계: 빠른 사전 필터링
            if (r < 60 || g < 60 || b > 180) return false;
            
            // 2단계: RGB 비율 기반 노란색 판정
            const rgSum = r + g;
            const isYellowish = (rgSum > 2.2 * b) && (r >= 0.7 * g) && (g >= 0.7 * r);
            
            // 3단계: 밝기 조건
            const brightness = (r + g + b) / 3;
            const hasSufficientBrightness = brightness >= 50;
            
            return isYellowish && hasSufficientBrightness;
        }
        function isInteriorAllYellow(checkBox) {
            const {x, y, width, height} = checkBox;
            if (width <= 4 || height <= 4) return false;

            // 테두리를 더 많이 제외하고 중심부 집중 검사
            const margin = Math.max(2, Math.floor(Math.min(width, height) * 0.25));
            const startX = x + margin;
            const startY = y + margin;
            const w = width - (margin * 2);
            const h = height - (margin * 2);

            if (w <= 0 || h <= 0) return false;

            const imgData = drawingCtx.getImageData(startX, startY, w, h);
            const data = imgData.data;

            // 전체 픽셀의 20%만 샘플링 (성능 향상)
            const totalPixels = w * h;
            const sampleCount = Math.max(5, Math.floor(totalPixels * 0.2));
            const step = Math.max(1, Math.floor(totalPixels / sampleCount));

            let yellowPixelCount = 0;
            let totalSampled = 0;

            for (let i = 0; i < data.length; i += (4 * step)) {
                if (i + 2 >= data.length) break;
                
                const r = data[i];
                const g = data[i + 1]; 
                const b = data[i + 2];

                if (isPixelYellowOptimized(r, g, b)) {
                    yellowPixelCount++;
                }
                totalSampled++;
            }

            // 70% 이상이 노란색이면 DEFAULT_N으로 판정
            const yellowRatio = yellowPixelCount / totalSampled;
            return yellowRatio >= 0.7;
            }
        // 이벤트 리스너 추가
        document.addEventListener('DOMContentLoaded', function() {
            const drawingCanvas = document.getElementById('drawingCanvas');
            const barcodeInput = document.getElementById('barcodeInput');
            const checkCompleteButton = document.getElementById('checkCompleteButton');
            
            // 오른쪽 클릭 방지
            drawingCanvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            
            drawingCanvas.addEventListener('pointerup', function() {
                isCheckSheetModified = true;
            });
            // 픽셀 색이 '노란색'인지 판단하는 헬퍼 함수 (오차 허용)
            
            // 체크박스 클릭 이벤트 핸들러
            drawingCanvas.addEventListener('click', function(event) {
                event.preventDefault(); // 기본 동작 방지
                event.stopPropagation(); // 이벤트 버블링 방지

                isCheckSheetModified = true;
                
                const rect = drawingCanvas.getBoundingClientRect();
                const clickPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                const selectedProcess = document.getElementById('processSelect').value;
                // 가장 가까운 체크박스 찾기
                const closestCheckboxIndex = findClosestCheckbox(clickPosition, checkBoxes, 50);
                if (closestCheckboxIndex !== -1) {
                    const clickedCheckbox = checkBoxes[closestCheckboxIndex];
                    const centerX = clickedCheckbox.x + clickedCheckbox.width / 2;
                    const centerY = clickedCheckbox.y + clickedCheckbox.height / 2;
                    
                    let state = checkBoxStates[closestCheckboxIndex] || 'default';
                    // 원래 상태를 저장할 배열 추가

                    if (state === 'default') {
                        if (isInteriorAllYellow(checkBoxes[closestCheckboxIndex])) {
                            state = 'default_n';
                        }
                        checkBoxStates[closestCheckboxIndex] = state;
                        originalStates[closestCheckboxIndex] = state;
                    }

                    // 체크박스 상태에 따라 이미지 그리기
                    switch (state) {
                        case 'default':
                            drawCheck(centerX, centerY);
                            checkBoxStates[closestCheckboxIndex] = 'checked';
                            break;
                        case 'default_n':
                            drawCheck(centerX, centerY);
                            checkBoxStates[closestCheckboxIndex] = 'checked';
                            break;
                        case 'checked':
                            clearCheckboxVisual(closestCheckboxIndex);
                            drawCross(centerX, centerY);
                            checkBoxStates[closestCheckboxIndex] = 'crossed';
                            break;
                        case 'crossed':
                            clearCheckboxVisual(closestCheckboxIndex);
                            drawCircleAndCheck(centerX, centerY);
                            checkBoxStates[closestCheckboxIndex] = 'rechecked';
                            break;
                        case 'rechecked':
                            clearCheckboxVisual(closestCheckboxIndex);   
                            checkBoxStates[closestCheckboxIndex] = originalStates[closestCheckboxIndex] || 'default';
                            break;
                    }

                    console.log(`체크박스 ${closestCheckboxIndex} 클릭 후 상태: ${checkBoxStates[closestCheckboxIndex]}`);

                    checkAllBoxesChecked();
                }
                
                // 바코드 입력 필드의 포커스 해제
                document.getElementById('barcodeInput').blur();
            });

            // 모든 체크박스가 체크되었는지 확인하는 함수
            function checkAllBoxesChecked() {
                if (is_checked_image) return; // 기존 이미지인 경우 함수 종료

                const allChecked = checkBoxes.every((box, index) => 
                    checkBoxStates[index] && checkBoxStates[index] !== 'default'
                );

                // if (allChecked) {
                //     checkCompleteButton.click();
                // }
            }
        });

        // 초기 설정 및 이벤트 리스너
        document.addEventListener('DOMContentLoaded', () => {
            var sidebar = document.getElementById("mySidebar");
            var main = document.getElementById("main");
            var openbtn = document.querySelector(".openbtn");

            // 사이드바 초기 상태 설정: 축소
            sidebar.classList.add('collapsed');
            sidebar.style.width = "50px";
            main.style.marginLeft = "50px";
            openbtn.innerHTML = "☰"; // 햄버거 아이콘 설정

            var employeeNameElement = document.getElementById('employeeName');
            var deptInfoElement = document.getElementById('deptInfo');
            
            if (employeeNameElement && deptInfoElement) {
                employeeNameElement.textContent = '{{ employee_name }}';
                deptInfoElement.textContent = '{{ dept_info }}';
            }
        });
        // 두 점 사이의 거리를 계산하는 함수
        function calculateDistance(point1, point2) {
            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
        }

        // 체크박스의 중심좌표를 계산하는 함수
        function getCheckboxCenter(checkbox) {
            return {
                x: checkbox.x + checkbox.width / 2,
                y: checkbox.y + checkbox.height / 2
            };
        }

        // 가장 가까운 체크박스를 찾는 함수
        function findClosestCheckbox(clickPosition, checkboxes, maxDistance = 50) {
            let closestIndex = -1;
            let minDistance = Infinity;
            
            checkboxes.forEach((checkbox, index) => {
                const checkboxCenter = getCheckboxCenter(checkbox);
                const distance = calculateDistance(clickPosition, checkboxCenter);
                
                // 최대 허용 거리 내에서 가장 가까운 체크박스 찾기
                if (distance <= maxDistance && distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });
            
            return closestIndex;
        }

        // 사이드바 토글 함수
        function toggleNav() {
            var sidebar = document.getElementById("mySidebar");
            var main = document.getElementById("main");
            var openbtn = document.querySelector(".openbtn");

            if (sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
                sidebar.style.width = "250px";
                main.style.marginLeft = "250px";
                openbtn.innerHTML = "×"; // 'X' 아이콘으 변경
            } else {
                sidebar.classList.add('collapsed');
                sidebar.style.width = "50px";
                main.style.marginLeft = "50px";
                openbtn.innerHTML = "☰"; // 햄버거 아이콘으로 변경
            }
        }

        function closeNav() {
            var sidebar = document.getElementById("mySidebar");
            var main = document.getElementById("main");
            var openbtn = document.querySelector(".openbtn");

            sidebar.classList.add('collapsed');
            sidebar.style.width = "50px";
            main.style.marginLeft = "50px";
            openbtn.innerHTML = "☰"; // 햄버거 아이콘으로 변경
        }

        // 모든 표시를 초기화하는 함수
        function clearAllDisplays() {
            // 기존 초기화 로직
            barcodeInput.textContent = '';
            indexNoDisplay.textContent = '';
            msCodeDisplay.textContent = '';
            serialNoDisplay.textContent = '';
            errorDisplay.textContent = '';
            constructionNoDisplay.textContent = '';
            baseCtx.clearRect(0, 0, baseImageCanvas.width, baseImageCanvas.height);
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // 캔버스 컨테이너와 제품 정보 컨테이너를 숨깁니다.
            document.getElementById('canvasContainer').style.display = 'none';
            document.getElementById('productInfoContainer').style.display = 'none';
            
            // 메시지 컨테이너의 내용을 비웁니다.
            const messagesContainer = document.getElementById('messages-container');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
        }

        function processBarcode(barcode) {
            if (barcode.length === 6) {
                // 공정 선택 드롭다운에서 마지막 공정 값을 가져옴
                const processSelect = document.getElementById('processSelect');
                const lastProcessValue = processSelect.options[processSelect.options.length - 1].value;
                const currentProcessValue = processSelect.value;

                // Settings.json에서 설정 가져오기
                fetch('/get_settings')
                .then(response => response.json())
                .then(settings => {
                    // 현재 선택된 공정이 마지막 공정이고 자동완료 코드가 입력된 경우
                    if (currentProcessValue === lastProcessValue && barcode === settings.autoCompleteCode) {
                        const checkCompleteBtn = document.getElementById('checkCompleteButton');
                        if (checkCompleteBtn) {
                            checkCompleteBtn.click();
                        }
                        return;
                    }
                    
                    fetchIndexNo(barcode);
                })
                .catch(error => {
                    console.error('설정 로드 오류:', error);
                    fetchIndexNo(barcode);
                });
            } else {
                errorDisplay.textContent = '6자리의 Index No를 입력해주세요.';
            }
        }

        // 체크 완료 버튼 클릭 이벤트 핸들러
        document.getElementById('checkCompleteButton').addEventListener('click', function() {
            // 필요한 정보가 모두 있는지 확인
            if (!indexNoDisplay.textContent || !serialNoDisplay.textContent || !document.getElementById('deptInfo').textContent) {
                alert('바코드를 먼저 입력해주세요. 모든 필요한 정보가 로드되어야 합니다.');
                return;
            }

            const selectedProcess = document.getElementById('processSelect').value;
            loadingSpinner.style.display = 'block'; // 로딩 스피너 표시

            // 이전 공정 체크 로직 제거 및 직접 체크시트 저장 및 완료 처리
            saveCheckSheet(selectedProcess);
        });

        // 체크시트 저장 및 완료 처리 함수 분리
        function saveCheckSheet(selectedProcess) {
            startDebugTimer('체크시트 저장');
            
            // 현재 Serial No를 저장
            const currentSerialNo = serialNoDisplay.textContent;
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            
            // 3186 공정인 경우 체크박스 검증
            if (deptCode === '3186') {
                // 모든 체크박스 확인
                let hasUncheckedItems = false;
                
                // 현재 페이지의 체크박스 확인
                for (let index in checkBoxStates) {
                    if (checkBoxStates[index] === 'default' || !checkBoxStates[index]) {
                        hasUncheckedItems = true;
                        break;
                    }
                }
                
                // 두 번째 페이지가 있는 경우 (공정 11)
                if (originalProcessCode === '11') {
                    // 현재 페이지 상태 저장
                    saveCurrentPageState();
                    
                    // page1CheckBoxStates 확인 (04번 페이지)
                    if (page1CheckBoxStates) {
                        for (let index in page1CheckBoxStates) {
                            if (page1CheckBoxStates[index] === 'default' || !page1CheckBoxStates[index]) {
                                hasUncheckedItems = true;
                                break;
                            }
                        }
                    }
                    
                    // page2CheckBoxStates 확인 (11번 페이지)
                    if (page2CheckBoxStates) {
                        for (let index in page2CheckBoxStates) {
                            if (page2CheckBoxStates[index] === 'default' || !page2CheckBoxStates[index]) {
                                hasUncheckedItems = true;
                                break;
                            }
                        }
                    }
                }
                
                // 미체크 항목이 있으면 모달 표시
                if (hasUncheckedItems) {
                    showUncheckedConfirmModal(selectedProcess, currentSerialNo, deptCode);
                    loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                    return;
                }
            }
            
            // JUXTA 공정 11인 경우만 두 페이지 모두 저장 (10은 기존 로직 유지) - 주석 처리됨
            /*
            if (deptCode === '3186' && originalProcessCode && originalProcessCode === '11') {
                // 현재 페이지 상태 저장
                saveCurrentPageState();
                
                // 두 페이지 모두 저장하는 함수
                saveBothPages(currentSerialNo, deptCode);
                return;
            }
            */
            
            // 일반적인 경우 (단일 페이지) - 새로 만든 함수 호출
            proceedWithSaving(selectedProcess, currentSerialNo, deptCode);
        }

        // 페이지가 로드되면 바코드 입력 필드에 자동으로 포커스를 맞춥니다.
        window.onload = function() {
            document.getElementById('barcodeInput').focus();
            initStickyHeader();
        };
        
        // Sticky header 초기화 함수
        function initStickyHeader() {
            const productInfoContainer = document.getElementById('productInfoContainer');
            const stickyPlaceholder = document.querySelector('.sticky-placeholder');
            let isImageLarge = false;
            let containerTop = 0;
            
            // 이미지 크기 체크 함수 - 전역으로 노출
            function checkImageSize() {
                const baseCanvas = document.getElementById('baseImageCanvas');
                const canvasContainer = document.getElementById('canvasContainer');
                
                if (!baseCanvas || !canvasContainer || canvasContainer.style.display === 'none') {
                    isImageLarge = false;
                    productInfoContainer.classList.add('no-sticky');
                    return;
                }
                
                // 이미지 높이가 화면 높이의 80% 이상이면 sticky 활성화
                const imageHeight = baseCanvas.height;
                const viewportHeight = window.innerHeight;
                isImageLarge = imageHeight > viewportHeight * 0.8;
                
                if (!isImageLarge) {
                    productInfoContainer.classList.add('no-sticky');
                    productInfoContainer.classList.remove('sticky');
                } else {
                    productInfoContainer.classList.remove('no-sticky');
                    updateStickyState();
                }
            }
            
            // Sticky 상태 업데이트
            function updateStickyState() {
                if (!productInfoContainer || productInfoContainer.style.display === 'none' || !isImageLarge) {
                    return;
                }
                
                // container의 원래 위치 저장
                if (!productInfoContainer.classList.contains('sticky')) {
                    const rect = productInfoContainer.getBoundingClientRect();
                    containerTop = rect.top + window.pageYOffset;
                }
                
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                // 스크롤 위치가 원래 위치를 지나면 sticky 적용
                if (scrollTop > containerTop && isImageLarge) {
                    if (!productInfoContainer.classList.contains('sticky')) {
                        productInfoContainer.classList.add('sticky');
                        // placeholder 높이 설정
                        if (stickyPlaceholder) {
                            stickyPlaceholder.style.height = productInfoContainer.offsetHeight + 'px';
                        }
                    }
                } else {
                    productInfoContainer.classList.remove('sticky');
                    if (stickyPlaceholder) {
                        stickyPlaceholder.style.height = '0';
                    }
                }
            }
            
            // 스크롤 이벤트 리스너
            let ticking = false;
            function requestTick() {
                if (!ticking) {
                    window.requestAnimationFrame(function() {
                        updateStickyState();
                        ticking = false;
                    });
                    ticking = true;
                }
            }
            
            window.addEventListener('scroll', requestTick);
            
            // 리사이즈 이벤트 리스너
            window.addEventListener('resize', function() {
                checkImageSize();
                updateStickyState();
            });
            
            // MutationObserver로 이미지 로드 감지
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && 
                        (mutation.attributeName === 'style' || mutation.attributeName === 'width' || mutation.attributeName === 'height')) {
                        setTimeout(checkImageSize, 100);
                    }
                });
            });
            
            const baseCanvas = document.getElementById('baseImageCanvas');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (baseCanvas) {
                observer.observe(baseCanvas, { attributes: true });
            }
            
            if (canvasContainer) {
                observer.observe(canvasContainer, { attributes: true });
            }
            
            // productInfoContainer 표시 상태 변경 감지
            if (productInfoContainer) {
                observer.observe(productInfoContainer, { attributes: true, attributeFilter: ['style'] });
            }
            
            // 전역으로 checkImageSize 함수 노출
            window.checkImageSizeForSticky = checkImageSize;
        }

        // 문서 전체에 대해 키 다운 이벤트를 캡쳐하고, 이벤트가 발생할 때마다
        // 바코드 입력 필드로 포커스를 옮기고 입력을 리다이렉트합니다.
        document.addEventListener('keydown', function(event) {
            const barcodeInput = document.getElementById('barcodeInput');
            if (document.activeElement !== barcodeInput) {
                barcodeInput.focus();
                if (event.key.length === 1 && ((event.key >= '0' && event.key <= '9') || (event.key >= 'A' && event.key <= 'Z') || (event.key >= 'a' && event.key <= 'z'))) {
                    barcodeInput.value = event.key;
                    const inputEvent = new Event('input', { bubbles: true });
                    barcodeInput.dispatchEvent(inputEvent);
                    event.preventDefault();
                }
            } else {
                // 엔터키가 눌렸을 때 처리
                if (event.key === 'Enter') {
                    event.preventDefault(); // 폼 제출 방지
                    if (barcodeInput.value.length === 6) {
                        const selectedProcess = document.getElementById('processSelect').value;
                        
                        // 이전 공정 체크 로직 제거 및 직접 바코드 처리
                        processBarcode(barcodeInput.value);
                        barcodeInput.value = '';
                    }
                }
            }
        });

        // DB에서 IndexNo를 조회하여 MSCODE, SerialNo 페이지에 표시하고 이미지를 로드합니다.
        const handleResponse = (data) => {
            // 응답에서 MS-CODE와 Serial No를 받아 페이지에 표시합니다.
            if (data.MS_CODE && data.Serial_No && data.Index_No && data.construction_No) {
                indexNoDisplay.textContent = data.Index_No;
                msCodeDisplay.textContent = data.MS_CODE;
                serialNoDisplay.textContent = data.Serial_No;
                constructionNoDisplay.textContent = data.construction_No || 'N/A';
                
                // MODEL 정보도 currentProductInfo에 저장
                if (data.MODEL) {
                    console.log('MODEL 정보:', data.MODEL);
                }
                errorDisplay.textContent = '';  // 에러 메시지를 초기화합니다.

            } else {
                indexNoDisplay.textContent = 'Unavailable';
                msCodeDisplay.textContent = 'Unavailable';
                serialNoDisplay.textContent = 'Unavailable';
                constructionNoDisplay.textContent = 'Unavailable';
                errorDisplay.textContent = data.error || 'An error occurred';  // 에러 메시지를 표시합니다.
            }
        };
            
        // 커스텀 확인 모달 표시 함수
        function showCustomConfirm(barcode) {
            const modal = document.getElementById('customConfirmModal');
            const saveBtn = document.getElementById('confirmSaveBtn');
            const cancelBtn = document.getElementById('confirmCancelBtn');
            const exitBtn = document.getElementById('confirmExitBtn');
            
            modal.style.display = 'block';
            
            // 취소 버튼에 포커스 설정
            setTimeout(() => {
                cancelBtn.focus();
            }, 100);
            
            // 저장 버튼 클릭 이벤트
            saveBtn.onclick = function() {
                modal.style.display = 'none';
                // 현재 체크시트 저장 후 새 바코드 처리
                const newBarcode = barcode;
                    
                    // 체크완료 버튼 클릭 이벤트를 직접 실행하고 완료될 때까지 대기
                    const checkCompleteBtn = document.getElementById('checkCompleteButton');
                    if (checkCompleteBtn) {
                        // 저장 프로세스 완료 후 새 바코드 처리를 위한 Promise 생성
                        new Promise((resolve) => {
                            checkCompleteBtn.addEventListener('click', function handler() {
                                checkCompleteBtn.removeEventListener('click', handler);
                                setTimeout(resolve, 1000); // 저장 프로세스 완료 대기
                            });
                            checkCompleteBtn.click();
                        }).then(() => {
                            // 저장이 완료된 후에 새 바코드 처리
                            clearAllDisplays(); // 화면 초기화
                            processNewBarcode(newBarcode);
                        });
                    }
            };
            
            // 취소 버튼 클릭 이벤트 - 모달만 닫기
            cancelBtn.onclick = function() {
                modal.style.display = 'none';
            };
            
            // 나가기 버튼 클릭 이벤트 - 초기화 처리
            exitBtn.onclick = function() {
                modal.style.display = 'none';
                // 현재 체크시트를 저장하지 않고 새 바코드 처리
                // 체크시트 수정 상태 초기화
                isCheckSheetModified = false;
                checkBoxStates = {};
                checkboxPositions = {};
                
                clearAllDisplays();  // 화면 초기화
                processNewBarcode(barcode);
            };
            
            // 모달 외부 클릭 시 모달만 닫기
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            };
            
            // ESC 키로 모달 닫기 시 초기화 처리
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && modal.style.display === 'block') {
                    modal.style.display = 'none';
                    // 현재 체크시트를 저장하지 않고 새 바코드 처리
                    // 체크시트 수정 상태 초기화
                    isCheckSheetModified = false;
                    checkBoxStates = {};
                    checkboxPositions = {};
                    
                    clearAllDisplays();  // 화면 초기화
                    processNewBarcode(barcode);
                }
            });
        }
        
        // 3186 공정 미체크 항목 확인 모달 표시 함수
        function showUncheckedConfirmModal(selectedProcess, currentSerialNo, deptCode) {
            const modal = document.getElementById('uncheckedConfirmModal');
            const saveBtn = document.getElementById('uncheckedSaveBtn');
            const cancelBtn = document.getElementById('uncheckedCancelBtn');
            
            modal.style.display = 'block';
            modal.dataset.selectedProcess = selectedProcess;
            modal.dataset.currentSerialNo = currentSerialNo;
            modal.dataset.deptCode = deptCode;
            
            // 저장 버튼 클릭 이벤트
            saveBtn.onclick = function() {
                modal.style.display = 'none';
                loadingSpinner.style.display = 'block';
                
                const selectedProcess = modal.dataset.selectedProcess;
                const currentSerialNo = modal.dataset.currentSerialNo;
                const deptCode = modal.dataset.deptCode;
                
                // 저장 로직 계속 진행
                continueSaveCheckSheet(selectedProcess, currentSerialNo, deptCode);
            };
            
            // 취소 버튼 클릭 이벤트
            cancelBtn.onclick = function() {
                modal.style.display = 'none';
                loadingSpinner.style.display = 'none';
            };
            
            // 모달 외부 클릭으로 닫기
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                    loadingSpinner.style.display = 'none';
                }
            };
            
            // ESC 키로 모달 닫기
            document.addEventListener('keydown', function handleEsc(event) {
                if (event.key === 'Escape' && modal.style.display === 'block') {
                    modal.style.display = 'none';
                    loadingSpinner.style.display = 'none';
                    document.removeEventListener('keydown', handleEsc);
                }
            });
        }
        
        // 저장 로직 계속 진행 함수
        function continueSaveCheckSheet(selectedProcess, currentSerialNo, deptCode) {
            // JUXTA 공정 11인 경우만 두 페이지 모두 저장 - 주석 처리됨
            /*
            if (deptCode === '3186' && originalProcessCode && originalProcessCode === '11') {
                saveBothPages(currentSerialNo, deptCode);
                return;
            }
            */
            
            // 기존 저장 로직 실행
            proceedWithSaving(selectedProcess, currentSerialNo, deptCode);
        }
        
        // 기존 저장 로직을 별도 함수로 분리
        function proceedWithSaving(selectedProcess, currentSerialNo, deptCode) {
            // 일반적인 경우 (단일 페이지)
            let anyCrossed = false;
            let checkboxSaveSuccess = false;
            let imageSaveSuccess = false;

            // 체크박스 상태 확인
            checkBoxes.forEach((box, index) => {
                if (checkBoxStates[index] === 'crossed') {
                    anyCrossed = true;
                }
                if(checkBoxStates[index] === 'default_n') {
                    anyCrossed = true;
                }
            });

            let result = anyCrossed ? 'NG' : 'OK';

            // 체크박스 상태와 위치를 서버로 전송
            const checkboxData = {
                indexNo: indexNoDisplay.textContent,
                serialNo: serialNoDisplay.textContent,
                deptCode: deptCode,
                processCode: selectedProcess,
                checkboxStates: checkBoxStates,
                originalStates: originalStates,
                checkboxPositions: checkBoxes.reduce((acc, box, index) => {
                    acc[index] = {
                        x: box.x,
                        y: box.y,
                        width: box.width,
                        height: box.height
                    };
                    return acc;
                }, {}),
                empNo: document.getElementById('employeeName').textContent.split(' ')[0]
            };

            fetch('/save_checkbox_states', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(checkboxData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                checkboxSaveSuccess = true;
                endDebugTimer('체크시트 저장');
                startDebugTimer('이미지 저장');
                
                // 이미지 저장 로직
                const baseImageCanvas = document.getElementById('baseImageCanvas');
                const drawingCanvas = document.getElementById('drawingCanvas');
                const mergedCanvas = document.createElement('canvas');
                mergedCanvas.width = baseImageCanvas.width;
                mergedCanvas.height = baseImageCanvas.height;
                const mergedCtx = mergedCanvas.getContext('2d', { willReadFrequently: true });
                mergedCtx.drawImage(baseImageCanvas, 0, 0);
                mergedCtx.drawImage(drawingCanvas, 0, 0);

                mergedCanvas.toBlob(function(blob) {
                    const formData = new FormData();
                    formData.append('image', blob, 'checked_image.png');
                    formData.append('serialNo', serialNoDisplay.textContent);
                    formData.append('processCode', selectedProcess);
                    formData.append('deptCode', document.getElementById('deptInfo').textContent.split(' ')[0]);
                    formData.append('empNo', document.getElementById('employeeName').textContent.split(' ')[0]);
                    formData.append('indexNo', indexNoDisplay.textContent);
                    formData.append('result', result);

                    fetch('/save_checked_image', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                        if (data.success) {
                            showMessage(data.message, 'success', currentSerialNo);
                            isCheckSheetModified = false;
                        } else {
                            let errorMsg = data.message;
                            if (!data.db_saved && !data.file_saved) {
                                errorMsg = '체크시트 저장에 실패했습니다.';
                            } else if (!data.db_saved) {
                                errorMsg = '데이터베이스 저장에 실패했습니다.';
                            } else if (!data.file_saved) {
                                errorMsg = '이미지 파일 저장에 실패했습니다.';
                            }
                            showMessage(errorMsg, 'error');
                        }
                    })
                    .catch(error => {
                        loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                        console.error('Error:', error);
                        showMessage('체크시트 저장 중 오류가 발생했습니다.', 'error');
                    });
                });
            })
            .catch(error => {
                endDebugTimer('체크시트 저장');
                console.error('Error:', error);
                loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                showMessage('체크박스 데이터 저장 중 오류가 발생했습니다.', 'error');
            });
        }
        
        // 바코드가 6자리 입력되면 호출되는 함수
        function fetchIndexNo(barcode) {
            if (isCheckSheetModified) {
                showCustomConfirm(barcode);
            } else {
                clearAllDisplays();  // 화면 초기화
                processNewBarcode(barcode);
            }
        }

        function shouldSkipPreviousProcess(deptCode, processCode) {
            // 부서 코드(deptCode)에 따라 스킵할 공정(processCode) 목록을 정의
            const skipMap = {
                '3165': ['08', '06'],  // UTA 라인 → 08, 06은 이전 공정 체크 스킵
                '3186': ['04', '07']         // JUXTA 라인 → 04, 07은 이전 공정 체크 스킵
            };

            const skipProcesses = skipMap[deptCode] || [];
            return skipProcesses.includes(processCode);
        }

        function processNewBarcode(barcode) {
            startDebugTimer('제품 정보 조회');
            const selectedProcess = document.getElementById('processSelect').value;
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            loadingSpinner.style.display = 'block'; // 로딩 스피너 표시
            // DCS_HISTORY 테이블 체크
            fetch('/check_index_in_dcs_history', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    indexNo: barcode,
                    deptCode: deptCode 
                })
            })
            .then(response => response.json())
            .then(dcsData => {
                if (dcsData.exists) {
                    // DCS_HISTORY에 존재하는 경우
                    const productInfo = dcsData.productInfo;
                    // DATA_ST 확인
                    if (productInfo.DATA_ST === 'A') {
                        if (shouldSkipPreviousProcess(deptCode,selectedProcess)) {
                            fetchProductInfoAndImage(barcode, productInfo);
                            insert_dcs_history(barcode, productInfo);
                            return null; // Promise 체인 종료
                        } else {
                            // 그 외 공정은 이전 공정 체크 후 진행
                            return fetch('/check_previous_process', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    serialNo: productInfo.Serial_No,
                                    currentProcessCode: selectedProcess,
                                    deptCode: deptCode
                                })
                            })
                            .then(response => response.json())
                            .then(checkData => {
                                if (checkData.previousCompleted) {
                                    fetchProductInfoAndImage(barcode, productInfo);
                                    insert_dcs_history(barcode, productInfo);
                                } else {
                                    loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                    showMessage('이전 공정이 완료되지 않았습니다. 이전 공정을 먼저 완료해주세요.', 'error');
                                    document.getElementById('canvasContainer').style.display = 'none';
                                    barcodeInput.value = '';
                                }
                                return null; // Promise 체인 종료
                            });
                        }
                    } else {
                        // DATA_ST가 'A'가 아닌 경우
                        clearAllDisplays();
                        loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                        showMessage(`이미 REV UP된 제품입니다. REV UP된 바코드를 입력해주세요.`, 'error');
                        return null; // Promise 체인 종료
                    }
                } else {
                    // DCS_HISTORY에 존재하지 않는 경우 TDSC952 조회
                    const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
                    console.log('Sending deptCode to get_product_info:', deptCode);
                    return fetch('/get_product_info', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({'indexNo': barcode, 'deptCode': deptCode})
                    })
                    .then(response => response.json())
                    .then(tdscData => {
                        console.log('Received product info:', tdscData);
                        if (tdscData.error) {
                            loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                            showMessage('제품 정보를 찾을 수 없습니다.', 'error');
                            throw new Error(tdscData.error);
                        }
                        
                        // TDSC952에서 데이터를 찾은 경우, DCS_HISTORY 상태 확인
                        return fetch('/check_dcs_history_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                serialNo: tdscData.Serial_No,
                                processCode: selectedProcess
                            })
                        })
                        .then(response => response.json())
                        .then(dcsData => {
                            if (dcsData.exists) {
                                if (dcsData.data.dataSt === 'A') {
                                    // DATA_ST가 'A'인 경우 기존 로직 실행
                                    return fetch('/update_and_insert_product_info', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            indexNo: tdscData.Index_No,
                                            serialNo: tdscData.Serial_No,
                                            processCode: selectedProcess,
                                            dcsData: dcsData.data  // DCS_HISTORY 상태 정보 추가
                                        })
                                    })
                                    .then(response => response.json())
                                    .then(updateResult => {
                                        if (updateResult.error) {
                                            loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                            throw new Error(updateResult.error);
                                        }
                                        if (shouldSkipPreviousProcess(deptCode,selectedProcess)) {
                                            fetchProductInfoAndImage(barcode, tdscData);
                                            insert_dcs_history(barcode, tdscData);
                                        } else {
                                            return fetch('/check_previous_process', {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json',
                                                },
                                                body: JSON.stringify({
                                                    serialNo: tdscData.Serial_No,
                                                    currentProcessCode: selectedProcess,
                                                    deptCode: deptCode
                                                })
                                            })
                                            .then(response => response.json())
                                            .then(checkData => {
                                                if (checkData.previousCompleted) {
                                                    fetchProductInfoAndImage(barcode, tdscData);
                                                    insert_dcs_history(barcode, tdscData);
                                                } else {
                                                    loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                                    showMessage('이전 공정이 완료되지 않았습니다. 이전 공정을 먼저 완료해주세요.', 'error');
                                                    document.getElementById('canvasContainer').style.display = 'none';
                                                    barcodeInput.value = '';
                                                }
                                                return null; // Promise 체인 종료
                                            });
                                        }
                                        return null; // Promise 체인 종료
                                    });
                                } else {
                                    // DATA_ST가 'A'가 아닌 경우
                                    clearAllDisplays();
                                    loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                    showMessage(`이미 REV UP된 제품입니다. 바코드 ${dcsData.data.indexNo}를 입력해주세요.`, 'error');
                                    throw new Error('REV UP 제품');
                                }
                            } else {
                                if (shouldSkipPreviousProcess(deptCode,selectedProcess)) {
                                    fetchProductInfoAndImage(barcode, tdscData);
                                    insert_dcs_history(barcode, tdscData);
                                } else {
                                    return fetch('/check_previous_process', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            serialNo: tdscData.Serial_No,
                                            currentProcessCode: selectedProcess,
                                            deptCode: deptCode
                                        })
                                    })
                                    .then(response => response.json())
                                    .then(checkData => {
                                        if (checkData.previousCompleted) {
                                            fetchProductInfoAndImage(barcode, tdscData);
                                            insert_dcs_history(barcode, tdscData);
                                        } else {
                                            loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                            showMessage('이전 공정이 완료되지 않았습니다. 이전 공정을 먼저 완료해주세요.', 'error');
                                            document.getElementById('canvasContainer').style.display = 'none';
                                            barcodeInput.value = '';
                                        }
                                        return null; // Promise 체인 종료
                                    });
                                }
                                return null; // Promise 체인 종료
                            }
                        });
                    });
                }
            })
            .then(response => {
                if (response) {
                    return response.json();
                }
                return null; // 이미 처리된 경우 null 반환
            })
            .catch(error => {
                if (error.message !== 'REV UP 제품') {
                    console.error('Error:', error);
                    loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                    showMessage('제품 정보 조회 중 오류가 발생했습니다.', 'error');
                }
            });
        }

        function insert_dcs_history(barcode, productInfo){
            const selectedProcess = document.getElementById('processSelect').value;
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            // DCS_HISTORY에 삽입
            const formData = new FormData();
            
            // productInfo가 있으면 사용, 없으면 display elements에서 가져옴
            const serialNo = productInfo ? productInfo.Serial_No : serialNoDisplay.textContent;
            const indexNo = productInfo ? productInfo.Index_No : (indexNoDisplay.textContent || barcode);
            
            if (!serialNo || !indexNo) {
                console.error('Missing required data for insert_dcs_history');
                return;
            }
            
            formData.append('serialNo', serialNo);
            formData.append('processCode', selectedProcess);
            formData.append('deptCode', deptCode);
            formData.append('empNo', document.getElementById('employeeName').textContent.split(' ')[0]);
            formData.append('indexNo', indexNo);
            fetch('/insert_dcs_history', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('Error from server:', data.error);
                } else {
                    console.log('Success:', data.message);
                }
            })
            .catch(err => {
                console.error('Network error:', err);
            });
        }
        // 제품 정보와 이미지를 가져오는 함수를 분리
        function fetchProductInfoAndImage(barcode, productInfo = null) {
            loadingSpinner.style.display = 'block'; // 로딩 스피너 표시
            startDebugTimer('이미지 로드');
            
            const loadImageWithProductInfo = (data) => {
                if (data.Serial_No) {
                    // 현재 제품 정보 저장
                    currentProductInfo = data;
                    
                    // 제품 정보 컨테이너와 체크 완료 버튼을 함께 표시
                    document.getElementById('productInfoContainer').style.display = 'flex';
                    document.getElementById('canvasContainer').style.display = 'block';
                    
                    const processSelect = document.getElementById('processSelect');
                    const selectedIndex = processSelect.selectedIndex;
                    const selectedProcess = processSelect.options[selectedIndex].value;
                    const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];

                    // JUXTA (dept 3186) 공정 11인 경우만 특별 처리 (10은 기존 로직 유지) - 주석 처리됨
                    /*
                    if (deptCode === '3186' && selectedProcess === '11') {
                        // VJ77 모델이 아닌 경우에만 페이지 네비게이션 활성화
                        if (data.MODEL !== 'VJ77') {
                            console.log('MODEL이 VJ77이 아님, 페이지 네비게이션 활성화:', data.MODEL);
                            // 원래 공정 코드 저장
                            originalProcessCode = selectedProcess;
                            
                            // 페이지 네비게이션 버튼 표시
                            document.getElementById('pageNavigation').style.display = 'inline-block';
                            
                            // 페이지 상태 초기화 (새로운 바코드 입력 시)
                            currentPage = 1;
                            page1Canvas = null;
                            page2Canvas = null;
                            page1CheckBoxStates = {};
                            page2CheckBoxStates = {};
                            
                            // 버튼 상태 초기화
                            document.getElementById('prevPageButton').disabled = true;
                            document.getElementById('nextPageButton').disabled = false;
                            
                            // 04번 공정 이미지 먼저 로드
                            const firstPageUrl = `/upload_image/${data.Index_No}_${deptCode}_${data.Serial_No}_04_${selectedIndex}`;
                            
                            // 11번 공정일 때 04페이지에서 체크완료 버튼 비활성화 (VJ77 제외)
                            const checkCompleteBtn = document.getElementById('checkCompleteButton');
                            if (checkCompleteBtn && selectedProcess === '11') {
                                checkCompleteBtn.disabled = true;
                                checkCompleteBtn.style.backgroundColor = '#ccc';
                                checkCompleteBtn.style.cursor = 'not-allowed';
                            }
                        
                        console.log('04번 공정 이미지 요청 URL:', firstPageUrl);
                        fetch(firstPageUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            }
                        })
                        .then(response => {
                            console.log('04번 공정 응답 상태:', response.status, response.ok);
                            if (!response.ok) {
                                loadingSpinner.style.display = 'none';
                                showMessage('04번 공정 이미지를 서버에서 가져오는데 실패했습니다.', 'error');
                                throw new Error('04번 공정 이미지를 서버에서 가져오는데 실패했습니다.');
                            }
                            return response.json();
                        })
                        .then(imageData => {
                            console.log('04번 공정 이미지 데이터:', imageData);
                            if (imageData.error) {
                                console.error('서버 에러:', imageData.error);
                                loadingSpinner.style.display = 'none';
                                showMessage(`서버 에러: ${imageData.error}`, 'error');
                                throw new Error(imageData.error);
                            }
                            if (imageData.image_url) {
                                is_checked_image = imageData.is_checked_image;
                                loadImage(imageData.image_url);
                                loadingSpinner.style.display = 'none';
                                checkBoxes = imageData.checkboxes || [];
                                
                                // 04번 공정의 체크박스 상태 가져오기
                                return fetch(`/get_checkbox_states?indexNo=${encodeURIComponent(data.Index_No)}&serialNo=${encodeURIComponent(data.Serial_No)}&processCode=04&deptCode=${encodeURIComponent(deptCode)}`);
                            } else {
                                loadingSpinner.style.display = 'none';
                                console.error('이미지 URL 없음, 전체 응답:', imageData);
                                showMessage('04번 공정 이미지 URL이 없습니다.', 'error');
                                throw new Error('04번 공정 이미지 URL이 없습니다.');
                            }
                        })
                        .then(response => response.json())
                        .then(states => {
                            // 04번 공정 체크박스 상태 초기화
                            if (is_checked_image) {
                                checkBoxStates = states;
                                page1CheckBoxStates = {...states};
                            } else {
                                checkBoxStates = {};
                                checkBoxes.forEach((_, index) => {
                                    checkBoxStates[index] = 'default';
                                    if (isInteriorAllYellow(checkBoxes[index])) {
                                        checkBoxStates[index] = 'default_n';
                                    }
                                    originalStates[index] = checkBoxStates[index];
                                });
                                page1CheckBoxStates = {...checkBoxStates};
                            }
                            redrawCheckboxes();
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            loadingSpinner.style.display = 'none';
                        });
                        } else {
                            // VJ77 모델인 경우 - 페이지 네비게이션 숨기고 해당 공정만 로드
                            console.log('MODEL이 VJ77, 페이지 네비게이션 비활성화');
                            document.getElementById('pageNavigation').style.display = 'none';
                            
                            // 페이지 상태 초기화
                            originalProcessCode = null;
                            currentPage = 1;
                            page1Canvas = null;
                            page2Canvas = null;
                            page1CheckBoxStates = {};
                            page2CheckBoxStates = {};
                            
                            // 선택된 공정(10 또는 11) 이미지 바로 로드
                            const uploadImageUrl = `/upload_image/${data.Index_No}_${deptCode}_${data.Serial_No}_${selectedProcess}_${selectedIndex}`;
                            
                            fetch(uploadImageUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            })
                            .then(response => {
                                if (!response.ok) {
                                    loadingSpinner.style.display = 'none';
                                    showMessage('이미지를 서버에서 가져오는데 실패했습니다.', 'error');
                                    throw new Error('이미지를 서버에서 가져오는데 실패했습니다.');
                                }
                                return response.json();
                            })
                            .then(data => {
                                loadingSpinner.style.display = 'none';
                                if (data.image_url) {
                                    const img = new Image();
                                    img.onload = function() {
                                        displayCheckBoxImage(img, data.checkboxes || [], data.is_checked_image);
                                    };
                                    img.src = data.image_url;
                                } else {
                                    showMessage('이미지 URL이 없습니다.', 'error');
                                }
                            })
                            .catch(error => {
                                console.error('Error:', error);
                                loadingSpinner.style.display = 'none';
                            });
                        }
                    }
                    */
                    
                    // 기본 처리 로직으로 통합 (10번과 11번 공정 모두 기본 로직으로 처리)
                    if (deptCode === '3186' && (selectedProcess === '10' || selectedProcess === '11')) {
                        // JUXTA 공정 10인 경우 - 기존 로직 그대로 유지 (페이지 네비게이션 없이 단일 페이지)
                        document.getElementById('pageNavigation').style.display = 'none';
                        originalProcessCode = null;
                        currentPage = 1;
                        page1Canvas = null;
                        page2Canvas = null;
                        page1CheckBoxStates = {};
                        page2CheckBoxStates = {};
                        
                        const uploadImageUrl = `/upload_image/${data.Index_No}_${deptCode}_${data.Serial_No}_${selectedProcess}_${selectedIndex}`;

                        fetch(uploadImageUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            }
                        })
                        .then(response => {
                            if (!response.ok) {
                                loadingSpinner.style.display = 'none';
                                showMessage('이미지를 서버에서 가져오는데 실패했습니다.', 'error');
                                throw new Error('이미지를 서버에서 가져오는데 실패했습니다.');
                            }
                            return response.json();
                        })
                        .then(imageData => {
                            if (imageData.image_url) {
                                is_checked_image = imageData.is_checked_image;
                                loadImage(imageData.image_url);
                                loadingSpinner.style.display = 'none';
                                checkBoxes = imageData.checkboxes || [];
                                return fetch(`/get_checkbox_states?indexNo=${encodeURIComponent(data.Index_No)}&serialNo=${encodeURIComponent(data.Serial_No)}&processCode=${encodeURIComponent(selectedProcess)}&deptCode=${encodeURIComponent(deptCode)}`);
                            } else {
                                loadingSpinner.style.display = 'none';
                                showMessage('이미지 URL이 없습니다.', 'error');
                                throw new Error('이미지 URL이 없습니다.');
                            }
                        })
                        .then(response => response.json())
                        .then(states => {
                            if (is_checked_image) {
                                checkBoxStates = states;
                            } else {
                                checkBoxStates = {};
                                checkBoxes.forEach((_, index) => {
                                    checkBoxStates[index] = 'default';
                                    if (checkBoxStates[index] === 'default') {
                                        if (isInteriorAllYellow(checkBoxes[index])) {
                                            checkBoxStates[index] = 'default_n';
                                            let originalStates = {};
                                        }
                                        checkBoxStates[index] = checkBoxStates[index];
                                        originalStates[index] = checkBoxStates[index];
                                    }
                                    startDebugTimer(`체크박스 ${index} 상태: ${checkBoxStates[index]}`);
                                });
                            }
                            redrawCheckboxes();
                        })
                        .catch(error => {
                            console.error('체크박스 상태 불러오기 오류:', error);
                        });
                    } else {
                        // 일반적인 경우 (기존 로직) - 페이지 네비게이션 숨기기
                        document.getElementById('pageNavigation').style.display = 'none';
                        originalProcessCode = null;
                        currentPage = 1;
                        page1Canvas = null;
                        page2Canvas = null;
                        page1CheckBoxStates = {};
                        page2CheckBoxStates = {};
                        
                        const uploadImageUrl = `/upload_image/${data.Index_No}_${deptCode}_${data.Serial_No}_${selectedProcess}_${selectedIndex}`;

                        fetch(uploadImageUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            }
                        })
                        .then(response => {
                            if (!response.ok) {
                                loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                showMessage('이미지를 서버에서 가져오는데 실패했습니다.', 'error');
                                throw new Error('이미지를 서버에서 가져오는데 실패했습니다.');
                            }
                            return response.json();
                        })
                        .then(imageData => {
                            if (imageData.image_url) {
                                is_checked_image = imageData.is_checked_image;
                                loadImage(imageData.image_url);
                                loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                checkBoxes = imageData.checkboxes || [];
                                return fetch(`/get_checkbox_states?indexNo=${encodeURIComponent(data.Index_No)}&serialNo=${encodeURIComponent(data.Serial_No)}&processCode=${encodeURIComponent(selectedProcess)}&deptCode=${encodeURIComponent(deptCode)}`);
                            } else {
                                loadingSpinner.style.display = 'none'; // 로딩 스피너 숨김
                                showMessage('이미지 URL이 없습니다.', 'error');
                                throw new Error('이미지 URL이 없습니다.');
                            }
                        })
                        .then(response => response.json())
                        .then(states => {
                            if (is_checked_image) {
                                checkBoxStates = states;
                            } else {
                                checkBoxStates = {};
                                checkBoxes.forEach((_, index) => {
                                    checkBoxStates[index] = 'default';
                                    if (checkBoxStates[index] === 'default') {
                                        if (isInteriorAllYellow(checkBoxes[index])) {
                                            checkBoxStates[index] = 'default_n';  // 내부가 전부 노란색이면 default_n
                                            let originalStates = {};
                                        }
                                        checkBoxStates[index] = checkBoxStates[index];
                                        originalStates[index] = checkBoxStates[index];  // 원래 상태 저장
                                    }
                                    startDebugTimer(`체크박스 ${index} 상태: ${checkBoxStates[index]}`);
                                });
                            }
                            redrawCheckboxes();
                        })
                        .catch(error => {
                            console.error('체크박스 상태 불러오기 오류:', error);
                        });
                    }
                }
            };

            // 항상 get_product_info를 호출하여 최신 construction_No 정보를 가져옴
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            console.log('Sending deptCode to get_product_info:', deptCode);
            fetch('/get_product_info', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({'indexNo': barcode, 'deptCode': deptCode})
            })
            .then(response => response.json())
            .then(data => {
                console.log('Received product info:', data);
                if (data.error) {
                    // 에러가 있는 경우 기존 productInfo를 사용
                    if (productInfo) {
                        handleResponse(productInfo);
                        loadImageWithProductInfo(productInfo);
                    } else {
                        showMessage('제품 정보를 가져오는 중 오류가 발생했습니다.', 'error');
                    }
                } else {
                    // 성공한 경우 새로운 데이터 사용
                    handleResponse(data);
                    loadImageWithProductInfo(data);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                // 에러 발생시 기존 productInfo가 있으면 사용
                if (productInfo) {
                    handleResponse(productInfo);
                    loadImageWithProductInfo(productInfo);
                } else {
                    showMessage('제품 정보를 가져오는 중 오류가 발생했습니다.', 'error');
                }
            });
            endDebugTimer('이미지 로드');
        }

        // 바코드 입력 필드에 영문과 숫자만 입력 허용
        function validateInput(input) {
            // 입력된 문자를 영문 대문자로 변환
            input.value = input.value.toUpperCase();
            
            // 영문자와 숫자만 허용
            const alphanumericRegex = /[^A-Z0-9]/g;
            input.value = input.value.replace(alphanumericRegex, '');
            
            // // 입력 길이가 변경되면 기존 정보 초기화
            // if (input.value.length === 0 || input.value.length > 0) {
            //     clearAllDisplays();
            // }
        }

        const LONG_PRESS_TIME = 1000; // 길게 누르기로 간주할 시간 (밀리초)
        let isLongPress = false; // 길게 누르기 상태를 저장하는 변수
        let drawing = false; // 그리기 상태
        // 우클릭 드래그를 감지하기 위한 변수
        let rightClickDragging = false;
        // eraserMode는 이미 전역 변수로 선언됨
        let startX, startY;  // 드래그 시작 좌표

        // 체크박스 영역을 나타내는 배열 (실제 사용 시 서버로부터 받아온 데이터 사용)
        let checkBoxes = []; // 예시 데이터
        // 체크박스 상태 관리
        // 각 체크박스에 대해 'default', 'checked', 'crossed' 등의 상태를 저장합니다.
        let checkBoxStates = {};
        let originalStates = {};

        // 이미지를 로드하는 함수
        function loadImage(url) {
            console.log('loadImage 함수 호출됨, URL 길이:', url ? url.length : 0);
            const image = new Image();
            image.onload = function() {
                console.log('이미지 로드 성공, 크기:', image.width, 'x', image.height);
                baseImageCanvas.width = image.width;
                baseImageCanvas.height = image.height;
                drawingCanvas.width = image.width;
                drawingCanvas.height = image.height;
                // 컨테이너 크기도 이미지 크기에 맞게 조정
                const canvasContainer = document.getElementById('canvasContainer');
                canvasContainer.style.width = image.width + 'px';
                canvasContainer.style.height = image.height + 'px';
                console.log('캔버스 컨테이너 표시 상태:', canvasContainer.style.display);

                baseCtx.drawImage(image, 0, 0);
                drawingCtx.drawImage(image, 0, 0);
                console.log('캔버스에 이미지 그리기 완료');
                
                // Sticky header 체크 - 이미지 로드 완료 후 실행
                if (typeof window.checkImageSizeForSticky === 'function') {
                    setTimeout(window.checkImageSizeForSticky, 100);
                }

                // 이미지 로드 후 해당 캔버스로 스크롤 이동
                document.getElementById('baseImageCanvas').scrollIntoView({ behavior: 'smooth' });
                
                // 지우개 버튼 표시
                document.getElementById('eraserButton').style.display = 'block';

            };
            image.onerror = function() {
                // 이미지 로드에 실패한 경우 에러 처리
                console.error('Failed to load image at ' + url);
            };
            image.src = url;
        }

        // 그리기 시작
        drawingCanvas.onpointerdown = function(event) {
            event.preventDefault();
            isLongPress = false;
            let timer = setTimeout(() => isLongPress = true, LONG_PRESS_TIME);

            const {x, y} = getCursorPosition(event);

            // 우클릭 검사
            if (event.button === 2) {
                const {x, y} = getCursorPosition(event);
                if (!isInsideCheckbox(x, y)) {
                    rightClickDragging = true;
                    startX = x;
                    startY = y;
                    event.preventDefault();  // 컨텍스트 메뉴 방지
                }
            } else if (event.button === 0) {
                // 좌클릭 처리
                // 지우개 모드일 때는 지우기 시작
                if (eraserMode) {
                    if (!isInsideCheckbox(x, y)) {
                        rightClickDragging = true; // 지우개 모드에서는 좌클릭도 지우기로 동작
                        startX = x;
                        startY = y;
                    }
                } else {
                    // 일반 그리기 모드
                    // 체크박스 내부에서는 그리지 않음
                    if (!isInsideCheckbox(x, y)) {
                        drawing = true;
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(x, y);
                    } else {
                        // 체크박스 내부에서 길게 눌렀을 때의 처리
                        document.body.addEventListener('pointerup', () => {
                            clearTimeout(timer);
                            if (isLongPress) {
                                redrawCheckbox(getCheckboxIndex(x, y));
                            }
                        }, {once: true});
                    }
                }
            }
        };

        // 그리기 진행
        drawingCanvas.onpointermove = function(event) {
            event.preventDefault();
            if (rightClickDragging) {
                const {x, y} = getCursorPosition(event);

                // 각 체크박스를 순회하면서 포인터 위치가 체크박스 내부인지 확인합니다.
                checkBoxes.forEach(function(checkBox, index) {
                    if (x >= checkBox.x && x <= checkBox.x + checkBox.width &&
                        y >= checkBox.y && y <= checkBox.y + checkBox.height) {
                        // 포인터가 체크박스 내부로 들어간 경우 상태를 default로 설정합니다.
                        checkBoxStates[index] = 'default';

                        // 선택적으로 체크박스 상태가 변경됨을 사용자에게 시각적으로 표시할 수 있습니다.
                        clearCheckboxVisual(index);
                    }
                });

                eraseLine(startX, startY, x, y);
                startX = x;
                startY = y;
            } else {
                if (drawing) {
                    const {x, y} = getCursorPosition(event);
                    drawingCtx.lineTo(x, y);
                    drawingCtx.strokeStyle = 'blue';
                    drawingCtx.lineWidth = 2;
                    drawingCtx.stroke();
                }
            }
        };

        // 그리기 종료
        drawingCanvas.onpointerup = function(event) {
            event.preventDefault();
            if ((event.button === 2 || (event.button === 0 && eraserMode)) && rightClickDragging) {
                rightClickDragging = false;
            } else {
                if (drawing) {
                    drawingCtx.closePath();
                    drawing = false;
                }
            }
        };

        drawingCanvas.onpointerleave = function(event) {
            event.preventDefault();
            if (drawing) {
                drawingCtx.closePath();
                drawing = false;
            }
        };

        // 커서 위치 계산
        function getCursorPosition(event) {
            const rect = drawingCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            return { x, y };
        }
        // 체크박스 내부 확인
        function isInsideCheckbox(x, y) {
            return checkBoxes.some(box => 
                x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height
            );
        }

        // 체크박스 인덱스 가져오기
        function getCheckboxIndex(x, y) {
            return checkBoxes.findIndex(box => 
                x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height
            );
        }

        function processClick(event) {
            if (isLongPress) return; // 길게 누르기 상태에서는 추가 동작을 수행하지 않음

            const rect = drawingCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            checkBoxes.forEach(function(checkBox, index) {
                const centerX = checkBox.x + checkBox.width / 2;
                const centerY = checkBox.y + checkBox.height / 2; // Y 위치 조정

                if (x >= checkBox.x && x <= (checkBox.x + checkBox.width) &&
                    y >= checkBox.y && y <= (checkBox.y + checkBox.height)) {
                    const state = checkBoxStates[index] || 'default';

                    if (event.button === 0 && state === 'default') { // 왼쪽 버튼 클릭 및 상태 확인
                        drawCheck(centerX, centerY);
                        checkBoxStates[index] = 'checked';
                    } else if (event.button === 2 && state === 'default') {
                        drawCross(centerX, centerY);
                        checkBoxStates[index] = 'crossed';
                    }
                }
            });
        }

        // 각 도형을 체크박스 가운데에 그리는 함수
        function drawCheck(x, y) {
            drawingCtx.beginPath();
            drawingCtx.moveTo(x - 5, y - 5); // V자의 시작 위치를 조정
            drawingCtx.lineTo(x, y + 5);
            drawingCtx.lineTo(x + 5, y - 5);
            drawingCtx.strokeStyle = 'blue';
            drawingCtx.lineWidth = 2;
            drawingCtx.stroke();
        }
        function drawCross(centerX, centerY) {
            let lineLength = 10; // X자를 그릴 때 각 선의 길이

            drawingCtx.beginPath();
            // 왼쪽 위에서 시작하여 오른쪽 아래로 선을 그립니다.
            drawingCtx.moveTo(centerX - lineLength / 2, centerY - lineLength / 2);
            drawingCtx.lineTo(centerX + lineLength / 2, centerY + lineLength / 2);
            // 오른쪽 위에서 시작하여 왼쪽 아래로 선을 그립니다.
            drawingCtx.moveTo(centerX + lineLength / 2, centerY - lineLength / 2);
            drawingCtx.lineTo(centerX - lineLength / 2, centerY + lineLength / 2);

            drawingCtx.strokeStyle = 'red';
            drawingCtx.lineWidth = 2;
            drawingCtx.stroke();
        }

        // 동그라미와 체크를 그리는 함수
        function drawCircleAndCheck(centerX, centerY) {
            // 체크박스 중심에 원 그리기
            drawingCtx.beginPath();
            drawingCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            drawingCtx.strokeStyle = 'red';
            drawingCtx.lineWidth = 2;
            drawingCtx.stroke();

            // 원 안에 X 그리기
            let lineLength = 10;
            drawingCtx.beginPath();
            drawingCtx.moveTo(centerX - lineLength / 2, centerY - lineLength / 2);
            drawingCtx.lineTo(centerX + lineLength / 2, centerY + lineLength / 2);
            drawingCtx.moveTo(centerX + lineLength / 2, centerY - lineLength / 2);
            drawingCtx.lineTo(centerX - lineLength / 2, centerY + lineLength / 2);
            drawingCtx.strokeStyle = 'red';
            drawingCtx.lineWidth = 2;
            drawingCtx.stroke();

            // 원의 우측에 V표시 추가
            drawCheck(centerX + 15, centerY);
        }
        function clearCheckboxVisual(index) {
            const checkBox = checkBoxes[index];
            // 체박스 영역과 그 주변을 더 넓게 지웁니다.
            drawingCtx.clearRect(checkBox.x - 20, checkBox.y - 10, checkBox.width + 40, checkBox.height + 20);
        }

        // 지우개 기능을 수행하 함수
        function eraseLine(x0, y0, x1, y1) {
            drawingCtx.globalCompositeOperation = 'destination-out';  // 현재 그려진 내용 지우기
            drawingCtx.beginPath();
            drawingCtx.moveTo(x0, y0);
            drawingCtx.lineTo(x1, y1);
            drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
            drawingCtx.lineWidth = 20;  // 지우개 선의 너비
            drawingCtx.stroke();
            drawingCtx.globalCompositeOperation = 'source-over';  // 다시 일반적인 드로잉 모드로 복귀
        }
        
        // 체크박스 초기화 및 다시 그리기
        function redrawCheckBox(index) {
            const checkBox = checkBoxes[index];
            // Clear the checkbox area
            drawingCtx.clearRect(checkBox.x, checkBox.y, checkBox.width, checkBox.height);
            // Optionally, redraw the checkbox border or background for visual clarity
            drawingCtx.strokeStyle = 'red';
            drawingCtx.strokeRect(checkBox.x, checkBox.y, checkBox.width, checkBox.height);
            checkBoxStates[index] = 'default';
        }

        // 체크박스 상태에 따라 이미지 그리기
        function redrawCheckboxes() {
            checkBoxes.forEach((box, index) => {
                const state = checkBoxStates[index] || 'default';
                const centerX = box.x + box.width / 2;
                const centerY = box.y + box.height / 2;
                
                switch (state) {
                    case 'checked':
                        drawCheck(centerX, centerY);
                        break;
                    case 'crossed':
                        drawCross(centerX, centerY);
                        break;
                    case 'rechecked':
                        drawCircleAndCheck(centerX, centerY);
                        break;
                }
            });
        }

        // 세션 확인 함수
        function checkSession() {
            return fetch('/check_login_status')
                .then(response => response.json())
                .then(data => {
                    if (!data.loggedIn) {
                        alert('로그인 후에 계속해주세요.');
                        window.location.href = '/login';
                        return false;
                    }
                    return true;
                })
                .catch(error => {
                    console.error('세션 확인 중 오류 발생:', error);
                    return false;
                });
        }

        function showMessage(message, type = 'error', serialNo = null) {
            const messagesContainer = document.getElementById('messages-container');
            if (!messagesContainer) {
                console.error('messages-container 요소를 찾을 수 없습니다.');
                return;
            }
            
            // 기존 메시지 제거
            messagesContainer.innerHTML = '';
            
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');

            // 타입에 따라 배경색 변경
            if (type === 'success') {
                messageDiv.style.backgroundColor = '#4CAF50'; // 녹색
            } else if (type === 'info') {
                messageDiv.style.backgroundColor = '#2196F3'; // 파란색
            } else {
                messageDiv.style.backgroundColor = '#f44336'; // 기본 빨간색
            }

            // 전달받은 Serial No 사용 또는 현재 표시된 Serial No 사용
            const displaySerialNo = serialNo || document.getElementById('serialNo').textContent || 'N/A';

            // 메시지와 Serial No를 함께 표시
            messageDiv.innerHTML = `<p>${message}</p><p><strong>Serial No:</strong> ${displaySerialNo}</p>`;
            messagesContainer.appendChild(messageDiv);
        }

        // 화면 초기화 함수
        function clearDisplays() {
            // 기존 이미지와 정보들을 초기화
            document.getElementById('indexNoDisplay').textContent = '';
            document.getElementById('serialNoDisplay').textContent = '';
            // 체크시트 이미지 초기화
            const imageContainer = document.getElementById('imageContainer');
            if (imageContainer) {
                imageContainer.innerHTML = '';
            }
            // 체크박스 상태 초기화
            checkBoxStates = {};
        }

        // 제품 정보 조회 함수
        function fetchProductInfo(barcode) {
            const deptCode = document.getElementById('deptInfo').textContent.split(' ')[0];
            fetch('/get_product_info', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'indexNo': barcode,
                    'deptCode': deptCode
                })
            })
            .then(response => response.json())
            .then(data => handleProductInfo(data))
            .catch(error => {
                console.error('Error:', error);
                showMessage('제품 정보를 가져오는 중 오류가 발생했습니다.', 'error');
            });
        }

        // 시간 측정을 위한 전역 변수 추가
        let debugTimings = {
            startTime: null,
            endTime: null,
            logs: []
        };

        // 시간 측정 시작 함수
        function startDebugTimer(label) {
            debugTimings.startTime = performance.now();
            console.log(`[DEBUG] ${label} 시작`);
        }

        // 시간 측정 종료 함수
        function endDebugTimer(label) {
            debugTimings.endTime = performance.now();
            const duration = debugTimings.endTime - debugTimings.startTime;
            debugTimings.logs.push({
                label: label,
                duration: duration
            });
            console.log(`[DEBUG] ${label} 종료: ${duration.toFixed(2)}ms`);
        }

        // 전체 로그 확인
        function showDebugLogs() {
            console.table(debugTimings.logs);
        }

        // 특정 작업의 평균 시간 확인
        function getAverageTime(label) {
            const logs = debugTimings.logs.filter(log => log.label === label);
            const avg = logs.reduce((acc, curr) => acc + curr.duration, 0) / logs.length;
            console.log(`${label} 평균 실행 시간: ${avg.toFixed(2)}ms`);
        }

        // 모든 페이지의 공통 스크립트에 추가
        function refreshSession() {
            fetch('/refresh_session', { 
                method: 'POST',
                credentials: 'same-origin'
            })
            .then(response => response.json())
            .then(data => {
                if (!data.valid) {
                    alert('세션이 만료되었습니다. 다시 로그인해주세요.');
                    window.location.href = '/login';
                }
            });
        }

        // 메시지 숨기는 함수 추가
        function hideMessage() {
            const messageElement = document.querySelector('.message');
            if (messageElement) {
                messageElement.remove();
            }
        }
        // 5분마다 세션 갱신
        setInterval(refreshSession, 300000);

        // fetch 요청에 대한 에러 처리는 각 fetch().catch()에서 처리
        // jQuery를 사용하지 않으므로 이 부분은 제거
        
        // 페이지 로드 완료 시 지우개 버튼 확인
        window.addEventListener('load', function() {
            console.log('페이지 로드 완료 - 지우개 버튼 상태 확인');
            const eraserBtn = document.getElementById('eraserButton');
            if (eraserBtn) {
                console.log('지우개 버튼 찾음, onclick:', eraserBtn.onclick);
                console.log('버튼 HTML:', eraserBtn.outerHTML);
            } else {
                console.error('지우개 버튼을 찾을 수 없음');
            }
        });
    </script>
</body>
</html>